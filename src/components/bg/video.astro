<style>
  #mars-canvas,
  #earth-canvas {
    width: clamp(4rem, 16rem, 33vw);
    height: clamp(4rem, 16rem, 33vw);
  }
  .hidden-video {
    position: absolute;
    width: 0;
    height: 0;
    pointer-events: none;
  }
</style>
<canvas
  id="earth-canvas"
  class="absolute z-20"
  style="left: clamp(2rem, 22vw, 36vw); bottom: clamp(2rem, 16vh, 28vh);"
></canvas>
<canvas
  id="mars-canvas"
  class="absolute z-20"
  style="right: clamp(2rem, 6vw, 8vw); top: clamp(2rem, 13vh, 16vh);"></canvas>
<video
  muted
  autoplay
  loop
  playsinline
  preload="auto"
  id="earth-video"
  width="256px"
  class="hidden-video"
>
  <source src="./portfolio/assets/background/earth.webm" type="video/webm" />
  <source src="./portfolio/assets/background/earth.mp4" type="video/mp4" />
</video>
<video
  muted
  autoplay
  loop
  playsinline
  preload="auto"
  id="mars-video"
  width="256px"
  class="hidden-video"
>
  <source src="./portfolio/assets/background/mars.webm" type="video/webm" />
  <source src="./portfolio/assets/background/mars.mp4" type="video/mp4" />
</video>
<script>
  function setupVideoProcessing(videoId, canvasId, colorTarget, threshold) {
    const videoElement = document.getElementById(videoId);
    const canvasElement = document.getElementById(canvasId);

    // Cast to specific element types
    const video = videoElement as HTMLVideoElement;
    const canvas = canvasElement as HTMLCanvasElement;
    const ctx = canvas.getContext("2d", { willReadFrequently: true });

    video.addEventListener("loadedmetadata", function () {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      video.play();
    });

    video.addEventListener("play", function () {
      const draw = () => {
        if (!video.paused && !video.ended) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

          // Process to remove the green screen color and add stroke
          processFrame(
            ctx,
            canvas.width,
            canvas.height,
            colorTarget,
            threshold
          );

          requestAnimationFrame(draw);
        }
      };
      draw();
    });
  }

  function processFrame(ctx, width, height, target, threshold) {
    let frame = ctx.getImageData(0, 0, width, height);
    let data = frame.data;
    let l = data.length / 4;

    // First pass: identify pixels to be made transparent
    let transparentPixels = new Set();
    for (let i = 0; i < l; i++) {
      let r = data[i * 4 + 0];
      let g = data[i * 4 + 1];
      let b = data[i * 4 + 2];
      if (colorMatches(r, g, b, target, threshold)) {
        transparentPixels.add(i);
      }
    }

    // Second pass: extend transparency to adjacent pixels
    transparentPixels.forEach((index: number) => {
      let x = index % width;
      let y = Math.floor(index / width);
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx !== 0 || dy !== 0) {
            let newIndex = (y + dy) * width + (x + dx);
            if (newIndex >= 0 && newIndex < l) {
              data[newIndex * 4 + 3] = 0; // Set alpha to 0 (transparent)
            }
          }
        }
      }
    });

    ctx.putImageData(frame, 0, 0);
  }

  function colorMatches(r, g, b, target, threshold) {
    return (
      Math.abs(r - target[0]) < threshold &&
      Math.abs(g - target[1]) < threshold &&
      Math.abs(b - target[2]) < threshold
    );
  }
  // Set up video processing for Mars and Earth videos with different thresholds
  setupVideoProcessing("mars-video", "mars-canvas", [22, 22, 255], 78);
  setupVideoProcessing("earth-video", "earth-canvas", [233, 0, 81], 78);
</script>
