---
import BackgroundUpsampler from "../components/background-upsampler";
interface Props {
  title: string;
}

const { title } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="description" content="made by jee-mj" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Smooch+Sans:wght@700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body id="body">
    <BackgroundUpsampler client:load />
    <!-- styling -->
    <div class="w-full h-4 bg-black absolute top-0 z-50"></div>
    <div class="w-full h-4 bg-black absolute bottom-0 z-50"></div>
    <div class="w-4 h-full bg-black absolute left-0 z-50"></div>
    <div class="w-4 h-full bg-black absolute right-0 z-50"></div>
    <style>
      #mars-canvas,
      #earth-canvas {
        width: clamp(4rem, 16rem, 33vw);
        height: clamp(4rem, 16rem, 33vw);
      }
      .hidden-video {
        position: absolute;
        top: 0;
        left: 0;
        width: 0;
        height: 0;
        z-index: -1;
        opacity: 0;
        pointer-events: none;
      }
    </style>
    <canvas
      id="earth-canvas"
      class="absolute z-0"
      style="left: clamp(2rem, 22vw, 36vw); bottom: clamp(2rem, 16vh, 28vh); width: clamp(4rem, 16rem, 33vw); height: clamp(4rem, 16rem, 33vw);"
    ></canvas>
    <canvas
      id="mars-canvas"
      class="absolute z-0"
      style="right: clamp(2rem, 6vw, 8vw); top: clamp(2rem, 13vh, 16vh); width: clamp(4rem, 16rem, 33vw); height: clamp(4rem, 16rem, 33vw);"
    ></canvas>
    <video
      autoplay
      muted
      loop
      playsinline
      preload="auto"
      id="earth-video"
      width="256px"
      class="hidden-video"
    >
      <source src="/assets/background/earth.webm" type="video/webm" />
    </video>
    <video
      autoplay
      muted
      loop
      playsinline
      preload="auto"
      id="mars-video"
      width="256px"
      class="hidden-video"
    >
      <source src="./assets/background/mars.webm" type="video/webm" />
    </video>

    <slot />
  </body>
  <script>
    function setupVideoProcessing(videoId, canvasId, colorTarget, threshold) {
      const videoElement = document.getElementById(videoId);
      const canvasElement = document.getElementById(canvasId);

      // Cast to specific element types
      const video = videoElement as HTMLVideoElement;
      const canvas = canvasElement as HTMLCanvasElement;
      const ctx = canvas.getContext("2d", { willReadFrequently: true });

      video.addEventListener("loadedmetadata", function () {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        video.play();
      });

      video.addEventListener("play", function () {
        const draw = () => {
          if (!video.paused && !video.ended) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // Process to remove the green screen color and add stroke
            processFrame(
              ctx,
              canvas.width,
              canvas.height,
              colorTarget,
              threshold
            );

            requestAnimationFrame(draw);
          }
        };
        draw();
      });
    }

    function processFrame(ctx, width, height, target, threshold) {
      let frame = ctx.getImageData(0, 0, width, height);
      let data = frame.data;
      let l = data.length / 4;

      // First pass: identify pixels to be made transparent
      let transparentPixels = new Set();
      for (let i = 0; i < l; i++) {
        let r = data[i * 4 + 0];
        let g = data[i * 4 + 1];
        let b = data[i * 4 + 2];
        if (colorMatches(r, g, b, target, threshold)) {
          transparentPixels.add(i);
        }
      }

      // Second pass: extend transparency to adjacent pixels
      transparentPixels.forEach((index: number) => {
        let x = index % width;
        let y = Math.floor(index / width);
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx !== 0 || dy !== 0) {
              let newIndex = (y + dy) * width + (x + dx);
              if (newIndex >= 0 && newIndex < l) {
                data[newIndex * 4 + 3] = 0; // Set alpha to 0 (transparent)
              }
            }
          }
        }
      });

      ctx.putImageData(frame, 0, 0);
    }

    function colorMatches(r, g, b, target, threshold) {
      return (
        Math.abs(r - target[0]) < threshold &&
        Math.abs(g - target[1]) < threshold &&
        Math.abs(b - target[2]) < threshold
      );
    }
    // Set up video processing for Mars and Earth videos with different thresholds
    setupVideoProcessing("mars-video", "mars-canvas", [22, 22, 255], 78);
    setupVideoProcessing("earth-video", "earth-canvas", [233, 0, 81], 78);
  </script>
</html>
